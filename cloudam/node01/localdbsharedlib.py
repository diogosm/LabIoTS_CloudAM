# -*- coding: utf-8 -*-
"""TestesProRasp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Ler3oLvMvdm0P6EBDFUyTQaDPRR8LB9
"""

import sqlite3
import time

import logging

'''
  @TODO 
    - verificar se dtype é válido
'''
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def create_table():
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()
  
  try:
    curs.execute("BEGIN") #COMEÇO DO TRANSACIONAL 
    curs.execute("""
      CREATE TABLE IF NOT EXISTS data (
      ID_DATA INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
      END_DEVICE_NAME TEXT NOT NULL,
      DTYPE TEXT NOT NULL,
      VALUE REAL,
      DATE_CREATED DATE NOT NULL,
      FIREBASE_SYNC BOOLEAN NOT NULL
      );
    """)
    conn.commit()
  except Exception as e:
    curs.rollback()
  finally:
    conn.close()
  

def dropa_table():
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()
  try:
    curs.execute("BEGIN") #COMEÇO DO TRANSACIONAL 
    curs.execute("""
      DROP TABLE IF EXISTS DATA;
    """)
    conn.commit()
  except Exception as e:
    curs.rollback()
  finally:
    conn.close()  


def insert(device_name, dtype, valor):
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()

  try: 
   curs.execute(f"INSERT INTO DATA (END_DEVICE_NAME, DTYPE, VALUE, DATE_CREATED,FIREBASE_SYNC) VALUES ('{device_name}', '{dtype}', {valor}, datetime('now'), FALSE)" ) 
  except Exception as e:
    logging.info("Error insert ${e}")
    conn.rollback()
  finally:
    conn.commit()
    conn.close()
  ## @TODO return true ou false
  return curs.lastrowid


def consultaLastRecord(device_name):
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()
  result_dict = []

  try:
    query = f"SELECT END_DEVICE_NAME, DTYPE, VALUE, max(DATE_CREATED) from data WHERE END_DEVICE_NAME = '{device_name}' group by DTYPE"
    curs.execute(query)
    results = curs.fetchall()
    for row in results:
      row_dict = {}
      for i, col in enumerate(curs.description):
        row_dict[col[0]] = row[i]
      result_dict.append(row_dict)
  except Exception as e:
    conn.commit()
    return []
  finally:
    conn.close()
 
  return result_dict

def returnDadosNotSYNC():
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()
  result_dict = []

  try:
    query = f"SELECT * FROM DATA WHERE FIREBASE_SYNC = FALSE"
    curs.execute(query)

    results = curs.fetchall()
    logging.info(results)

    for row in results:
      row_dict = {}
      for i, col in enumerate(curs.description):
        row_dict[col[0]] = row[i]
      result_dict.append(row_dict)
  except Exception as e:
    conn.commit()
    return []
  finally:
    conn.close()
 
  return result_dict

'''
  Função para atualizar dado sincronizado com o Firebase.
  Para isso, atualizamos o campo FIREBASE_SYNC para true no banco
  @params:
   - ID_DATA
'''
def atualizaTrue(id_data): 

  conn = sqlite3.connect('data.db')
  curs = conn.cursor()

  try:
    query = f"UPDATE DATA SET FIREBASE_SYNC = TRUE WHERE id_data = {id_data}"
    curs.execute(query)
  except Exception as e:
    conn.rollback()
    return False
  finally:
    conn.commit()
    conn.close()
  return True


def select_all_data():
  conn = sqlite3.connect('data.db')
  curs = conn.cursor()
  answer = []

  try:
    query = f"SELECT * FROM DATA"
    curs.execute(query)
    ans = curs.fetchall()
    for row in ans:
      row_dict = {}
      for i, col in enumerate(curs.description):
        row_dict[col[0]] = row[i]
      answer.append(row_dict)
  except Exception as e:
    logging.info(e, flush=True)
    return None
  finally:
    conn.commit()
    conn.close()
  return answer


